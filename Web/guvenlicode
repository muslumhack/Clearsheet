OS Command Injection
$userInput = $_GET['filename'];
$escapedInput = escapeshellarg($userInput);
$output = shell_exec("cat " . $escapedInput);

SQL Injection
$pdo = new PDO('mysql:host=localhost;dbname=test', 'username', 'password');
$stmt = $pdo->prepare('SELECT * FROM users WHERE email = ?');
$stmt->execute([$_POST['email']]);

Cross-Site Scripting (XSS)
$userInput = $_POST['username'];
$safeInput = htmlspecialchars($userInput, ENT_QUOTES, 'UTF-8');
echo "Hello, " . $safeInput;

Local File Inclusion (LFI)
$allowed_pages = ['home', 'about', 'contact'];
$page = $_GET['page'];
if (!in_array($page, $allowed_pages)) {
    die("Not allowed");
}
include($page . ".");

Remote File Inclusion (RFI):
RFI saldırılarına karşı en iyi savunma, kullanıcının sağladığı dış URL'lerin  tarafından yürütülmesini engellemektir. Bu, .ini dosyasında allow_url_include seçeneğini Off olarak ayarlayarak yapılabilir.

Unrestricted File Upload:
$allowedExtensions = ['jpg', 'png', 'gif'];
$fileName = $_FILES['userfile']['name'];
$ext = pathinfo($fileName, PATHINFO_EXTENSION);
if (!in_array($ext, $allowedExtensions)) {
    die("Not allowed file extension");
}
move_uploaded_file($_FILES['userfile']['tmp_name'], '/safe/path/' . $fileName);

Broken Authentication:
$hashed_password = password_hash($_POST['password'], PASSWORD_DEFAULT);
// Save the hashed password into database, and then during login
$hashed_password_from_db = // retrieve it from db
if (!password_verify($_POST['password'], $hashed_password_from_db)) {
    die("Invalid username or password");
}

Cross-Site Request Forgery (CSRF):
session_start();
$token = $_SESSION['csrf_token'];
if ($_POST['csrf_token'] != $token) {
    die("CSRF token mismatch");
}

XML External Entity (XXE) Attack:
libxml_disable_entity_loader(true);
$xml = simplexml_load_string($_POST['xmlData']);

Insecure Direct Object References (IDOR): Bir kullanıcının yetkisiz olarak başka bir kullanıcının verilerine erişmesini önlemek için sunucu tarafında her zaman yetki kontrolleri yapın:
$user_id = $_SESSION['user_id']; // Authenticated user ID
$requested_id = $_GET['id']; // ID user is attempting to access
if ($user_id !== $requested_id) {
    die("You are not allowed to access this data.");
}

Security Misconfiguration: Bu, genellikle yapılandırma hatalarından kaynaklanır. PHP'deki display_errors ayarını "off" yapmak, potansiyel atacılara uygulamanızın ayrıntılarını göstermemek için önemlidir:
ini_set('display_errors', '0');

Insecure Deserialization: PHP'de güvensiz deserialization'ı önlemek için unserialize() işleminden kaçının veya güvenli bir alternatif kullanın:
// Using JSON as a safer alternative to unserialize()
$safe_data = json_encode($data);
$restored_data = json_decode($safe_data);

Server Side Request Forgery (SSRF): SSRF saldırılarını önlemek için sunucu tarafında yapılan isteklerin girdi değerlerini kontrol edin ve URL'leri filtreleyin:
// Make sure you only connect to known hosts
$allowed_hosts = ['www.example.com', 'api.example.com'];
$url = parse_url($_GET['url']);
if (!in_array($url['host'], $allowed_hosts)) {
    die("Invalid URL");
}

Path Traversal: Kullanıcının gönderdiği dosya yollarını kontrol edin ve dosya yolu manipülasyonlarını önlemek için uygun işlevler kullanın:
$filename = basename($_GET['filename']); // Only allow simple filenames without any directory parts
$path = '/safe/path/' . $filename;
if (!file_exists($path)) {
    die("File not found");
}

Header Injection: Kullanıcı girişlerini headerlarda kullanırken temizlemek önemlidir:
$user_agent = str_replace(["\n","\r"], '', $_SERVER['HTTP_USER_AGENT']);
header("User-Agent: $user_agent");

Clickjacking (User Interface redress attack): Clickjacking saldırılarını önlemek için X-Frame-Options başlığını kullanabiliriz:
header('X-Frame-Options: DENY');


HTTP Verb Tampering: HTTP istek metodunu kontrol ederek POST, DELETE gibi metotları kullanıcı girişine göre ayarlamaktan kaçınabiliriz:
if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    exit;
}

HTTP Parameter Pollution (HPP): Tekil parametreler kullanarak HPP saldırılarından korunabiliriz:
// $_GET['id'] will only ever return the first 'id' query parameter
$id = $_GET['id'];


Missing Encryption of Sensitive Data: Hassas verileri şifreleyin:
// Example of password hashing
$password_hash = password_hash($password, PASSWORD_DEFAULT);

Insufficient Logging & Monitoring: Olayların yeterli bir şekilde kaydedilip izlenmediği durumlarda, bir saldırı meydana geldiğinde anlaşılmaz veya belirlenemez. PHP'de error_log işlevi, hataları ve istisnaları kaydetmek için kullanılabilir:
error_log('Error or exception message');

Sensitive Data Exposure: Sensitive data'ya (hassas veri) karşı koruma önemlidir. Bu, veritabanı bağlantı bilgileri, ödeme bilgileri veya kullanıcı bilgileri gibi bilgileri içerebilir. Bu tür bilgileri bir dosyada saklamak yerine bir ortam değişkeninde saklamak daha güvenlidir. PHP'de getenv fonksiyonunu kullanabilirsiniz:
$db_password = getenv('DB_PASSWORD');

Insufficient Session Expiration: Oturumların zamanında sona ermemesi, saldırganların kullanıcının oturumunu ele geçirme riskini artırabilir. Oturum süresini belirlemek için session.cookie_lifetime ayarını kullanabilirsiniz:
ini_set('session.cookie_lifetime', 600); // Set session expiration to 10 minutes

Unvalidated Redirects and Forwards: Redirect ve forward işlemleri sırasında kullanıcı girişlerini doğrulamamak saldırılara yol açabilir. Kullanıcıdan gelen URL'ler için doğrulama yapılması gereklidir:
$allowed_urls = ['https://www.yourwebsite.com', 'https://yourwebsite.com/login'];
if (!in_array($_GET['redirect'], $allowed_urls)) {
    die('Invalid redirect URL');
}
